package main

// Convert SRT subtitle file to ASS subtitle file
// Due to how SRT files get burned in with FFMPEG, it's not easy to control the Spacing between lines.
// This script will convert the SRT file into an ASS file with a specific Spacing between lines.

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
)

func main() {
	inputFile := "input.srt"
	outputFile := "output.ass"
	convertSRTtoASS(inputFile, outputFile)
}

func convertSRTtoASS(inputFile, outputFile string) {
	file, err := os.Open(inputFile)
	if err != nil {
		fmt.Println("Error opening input file:", err)
		return
	}
	defer file.Close()

	outFile, err := os.Create(outputFile)
	if err != nil {
		fmt.Println("Error creating output file:", err)
		return
	}
	defer outFile.Close()

	writeASSHeader(outFile)

	scanner := bufio.NewScanner(file)
	var lineCount int
	var startTime, endTime string
	var textLines []string
	timestampPattern := regexp.MustCompile(`(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})`)

	for scanner.Scan() {
		line := scanner.Text()
		lineCount++
		if lineCount == 1 {
			// Skip the sequence number line
			continue
		}

		if timestampPattern.MatchString(line) {
			matches := timestampPattern.FindStringSubmatch(line)
			startTime = matches[1]
			endTime = matches[2]
			continue
		}

		if line == "" {
			if len(textLines) > 0 {
				writeEvent(outFile, startTime, endTime, textLines)
				textLines = nil
			}
			lineCount = 0
		} else {
			textLines = append(textLines, line)
		}
	}

	// Write the last event if the file doesn't end with a blank line
	if len(textLines) > 0 {
		writeEvent(outFile, startTime, endTime, textLines)
	}

	if err := scanner.Err(); err != nil {
		fmt.Println("Error reading input file:", err)
	}
}

func convertTimestamp(input string) string {
	// Split the time part into hours, minutes, and seconds.milliseconds
	timeParts := strings.Split(input, ":")
	if len(timeParts) != 3 {
		return input // Return the original input if format is incorrect
	}

	secondsParts := strings.Split(timeParts[2], ".")
	if len(secondsParts) != 2 {
		return input // Return the original input if format is incorrect
	}

	// Convert milliseconds to a float and round to 2 decimal places
	secondsFloat, err := strconv.ParseFloat("0."+secondsParts[1], 64)
	if err != nil {
		return input // Return the original input if there's an error parsing milliseconds
	}
	secondsRounded := fmt.Sprintf("%.2f", secondsFloat)[1:] // Trim leading "0"

	// Remove leading zero from hours if present
	hours := strings.TrimPrefix(timeParts[0], "0")
	if hours == "" {
		hours = "0"
	}

	// Combine parts back into the desired format
	return fmt.Sprintf("%s:%s:%s%s", hours, timeParts[1], secondsParts[0], secondsRounded)
}

func writeASSHeader(outFile *os.File) {
	header := `[Script Info]
; Script generated by Aegisub 3.4.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Last Style Storage: Janik
Video Zoom Percent: 1.000000
Active Line: 16

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,14,&H00FFFFFF,&H000000FF,&HB5000000,&H00000000,0,0,0,0,100,100,0,0,3,2,0,2,20,20,30,1

[Events]
`
	outFile.WriteString(header)
}

func writeEvent(outFile *os.File, startTime, endTime string, textLines []string) {
	startTime = convertTimeFormat(startTime)
	endTime = convertTimeFormat(endTime)

	var text string
	if len(textLines) == 1 {
		text = textLines[0]
	} else if len(textLines) == 2 {
		text = fmt.Sprintf(`{\org(-2000000,0)\fr0.00011}%s{\r}\N%s`, textLines[0], textLines[1])
	} else {
		text = strings.Join(textLines, `\N`)
	}

	event := fmt.Sprintf("Dialogue: 0,%s,%s,Default,,0,0,0,,%s\n", startTime, endTime, text)
	outFile.WriteString(event)
}

func convertTimeFormat(srtTime string) string {
	return convertTimestamp(strings.Replace(srtTime[:12], ",", ".", 1))
}
